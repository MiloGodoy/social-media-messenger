import { __assign, __awaiter, __generator, __rest } from "tslib";
import { useCallback } from 'react';
import { nanoid } from 'nanoid';
import { useImageUploads } from './useImageUploads';
import { useFileUploads } from './useFileUploads';
import { checkUploadPermissions } from './utils';
import { useChannelActionContext, useChannelStateContext, useChatContext, useTranslationContext, } from '../../../context';
var apiMaxNumberOfFiles = 10;
export var useAttachments = function (props, state, dispatch, textareaRef) {
    var doFileUploadRequest = props.doFileUploadRequest, errorHandler = props.errorHandler, noFiles = props.noFiles;
    var fileUploads = state.fileUploads, imageUploads = state.imageUploads;
    var getAppSettings = useChatContext('useAttachments').getAppSettings;
    var t = useTranslationContext('useAttachments').t;
    var addNotification = useChannelActionContext('useAttachments').addNotification;
    var _a = useChannelStateContext('useAttachments'), channel = _a.channel, maxNumberOfFiles = _a.maxNumberOfFiles, multipleUploads = _a.multipleUploads;
    var _b = useFileUploads(props, state, dispatch), removeFile = _b.removeFile, uploadFile = _b.uploadFile;
    var _c = useImageUploads(props, state, dispatch), removeImage = _c.removeImage, uploadImage = _c.uploadImage;
    // Number of files that the user can still add. Should never be more than the amount allowed by the API.
    // If multipleUploads is false, we only want to allow a single upload.
    var maxFilesAllowed = !multipleUploads ? 1 : maxNumberOfFiles || apiMaxNumberOfFiles;
    // OG attachments should not be counted towards "numberOfImages"
    var numberOfImages = Object.values(imageUploads).filter(function (_a) {
        var og_scrape_url = _a.og_scrape_url, state = _a.state;
        return state !== 'failed' && !og_scrape_url;
    }).length;
    var numberOfFiles = Object.values(fileUploads).filter(function (_a) {
        var state = _a.state;
        return state !== 'failed';
    }).length;
    var numberOfUploads = numberOfImages + numberOfFiles;
    var maxFilesLeft = maxFilesAllowed - numberOfUploads;
    var uploadNewFiles = useCallback(function (files) {
        var _a;
        Array.from(files)
            .slice(0, maxFilesLeft)
            .forEach(function (file) {
            var _a;
            var id = nanoid();
            if (file.type.startsWith('image/') &&
                !file.type.endsWith('.photoshop') // photoshop files begin with 'image/'
            ) {
                dispatch({
                    file: file,
                    id: id,
                    previewUri: (_a = URL.createObjectURL) === null || _a === void 0 ? void 0 : _a.call(URL, file),
                    state: 'uploading',
                    type: 'setImageUpload',
                });
            }
            else if (file instanceof File && !noFiles) {
                dispatch({ file: file, id: id, state: 'uploading', type: 'setFileUpload' });
            }
        });
        (_a = textareaRef === null || textareaRef === void 0 ? void 0 : textareaRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [maxFilesLeft, noFiles]);
    var removeAttachment = function (id) {
        dispatch({ id: id, type: 'removeAttachment' });
    };
    var uploadAttachment = useCallback(function (att) { return __awaiter(void 0, void 0, void 0, function () {
        var $internal, attachment, id, file, canUpload, notificationText, response, uploadedAttachment, error_1, finalError, failedAttachment;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    $internal = att.$internal, attachment = __rest(att, ["$internal"]);
                    if (!($internal === null || $internal === void 0 ? void 0 : $internal.file))
                        return [2 /*return*/, att];
                    id = (_a = $internal === null || $internal === void 0 ? void 0 : $internal.id) !== null && _a !== void 0 ? _a : nanoid();
                    file = $internal.file;
                    return [4 /*yield*/, checkUploadPermissions({
                            addNotification: addNotification,
                            file: file,
                            getAppSettings: getAppSettings,
                            t: t,
                            uploadType: 'file',
                        })];
                case 1:
                    canUpload = _b.sent();
                    if (!canUpload) {
                        notificationText = t('Missing permissions to upload the attachment');
                        console.error(new Error(notificationText));
                        addNotification(notificationText, 'error');
                        return [2 /*return*/, att];
                    }
                    dispatch({
                        attachment: __assign(__assign({}, attachment), { $internal: __assign(__assign({}, $internal), { id: id, uploadState: 'uploading' }) }),
                        type: 'upsertAttachment',
                    });
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 7, , 8]);
                    response = void 0;
                    if (!doFileUploadRequest) return [3 /*break*/, 4];
                    return [4 /*yield*/, doFileUploadRequest(file, channel)];
                case 3:
                    response = _b.sent();
                    return [3 /*break*/, 6];
                case 4: return [4 /*yield*/, channel.sendFile(file)];
                case 5:
                    response = _b.sent();
                    _b.label = 6;
                case 6:
                    uploadedAttachment = __assign(__assign({}, attachment), { $internal: __assign(__assign({}, $internal), { uploadState: 'finished' }), asset_url: response.file });
                    dispatch({
                        attachment: uploadedAttachment,
                        type: 'upsertAttachment',
                    });
                    return [2 /*return*/, uploadedAttachment];
                case 7:
                    error_1 = _b.sent();
                    finalError = { message: t('Error uploading attachment'), name: 'Error' };
                    if (typeof error_1.message === 'string') {
                        finalError = error_1;
                    }
                    else if (typeof error_1 === 'object') {
                        finalError = Object.assign(finalError, error_1);
                    }
                    console.error(finalError);
                    addNotification(finalError.message, 'error');
                    failedAttachment = __assign(__assign({}, attachment), { $internal: __assign(__assign({}, $internal), { uploadState: 'failed' }) });
                    dispatch({
                        attachment: failedAttachment,
                        type: 'upsertAttachment',
                    });
                    if (errorHandler) {
                        errorHandler(finalError, 'upload-attachment', file);
                    }
                    return [2 /*return*/, failedAttachment];
                case 8: return [2 /*return*/];
            }
        });
    }); }, [addNotification, channel, doFileUploadRequest, dispatch, errorHandler, getAppSettings, t]);
    return {
        maxFilesLeft: maxFilesLeft,
        numberOfUploads: numberOfUploads,
        removeAttachment: removeAttachment,
        removeFile: removeFile,
        removeImage: removeImage,
        uploadAttachment: uploadAttachment,
        uploadFile: uploadFile,
        uploadImage: uploadImage,
        uploadNewFiles: uploadNewFiles,
    };
};
